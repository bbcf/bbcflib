* Infrastructure
** DONE Make module docs show up in Sphinx documentation      :documentation:
** DONE Add 'mailer' to README as a dependency	      :documentation:
** DONE Create test_data directory and add to repository	       :test:
** DONE Write a configuration file test.cfg in test_data	       :test:
Use the following template:
    [genrep]
    genrep_url=
    genrep_root=

    [daflims]:
    daflims_username=
    daflims_password=

    [emailreport]:
    email_from_address=
    email_smtp_server=
    email_default_subject=

    [frontend]:
    frontend_url=
** DONE Add import of appropriate things from each module to __init__.py :organization:
from genrep, GenRep, Assembly
from daflims, DAFLIMS,
from mail, EmailReport,
from frontend, Frontend
and ConfigParser from ConfigParse
** DONE Create test.py to run against test_data.		       :test:
Load test_data/test.cfg as a ConfigParser for use in the tests.
** DONE Add test_suite field to setup.py to enable python setup.py test :test:
http://ericholscher.com/blog/2009/jun/29/enable-setuppy-test-your-django-apps/
http://peak.telecommunity.com/DevCenter/setuptools#test

** DONE Write docstring for __init__.py			      :documentation:
* GenRep
** TODO Unit tests for genrep.py				       :test:
Test against http://bbcftools.vital-it.ch/genrep/ 
*** TODO Tests in test.py for GenRep.query_url 			       :test:
*** TODO Get JSON from GenRep for assemblies and chromosomes on GenRep, prettyprint it. :test:
*** TODO Put GenRep JSON as an Assembly object in test.py to test against. :test:
*** TODO Tests in test.py for GenRep.get_assembly 		       :test:
** TODO Write module docstring for genrep.py		      :documentation:
Tutorial on how to use it, what the GenRep is, how to set it up.
* EmailReport
** TODO Write class skeleton and init function for EmailReport	:emailreport:
Handle either from, to, subject, smtp_server, or config, section (default emailreport), and to
Set up Message object.  Use utf-8 charset.
** TODO Write appendBody method for EmailReport			:emailreport:
** TODO Write dump method for EmailReport that produces a dictionary of all the information :test:
** TODO Add a send method to EmailReport			:emailreport:
** TODO Formulate a test message and its dumped form, add it to test.py :test:
** TODO Write unit tests to check that dumped message is correct       :test:
** TODO Write documentation for EmailReport		      :documentation:
*** TODO Docstring for module				      :documentation:
*** TODO Docstring for EmailReport class		      :documentation:
*** TODO Docstring for EmailReport methods		      :documentation:

* DAFLIMS
** TODO Write class and constructor for DAFLIMS			    :daflims:
Either take username and password, or config and section (default "daflims").
** TODO Make DAFLIMS __init__ make sure it can connect to LIMS	    :daflims:
** TODO Track down a small file in the DAFLIMS I can fetch for testing purposes :test:
** TODO Adapt Jacques' fetch function into fetch_file		    :daflims:
def download_fastq( sample_descr, root="/scratch/frt/daily/htsserver/chipseq/" ):
    """Fetches fastq file for a given experiment from the Core Facilities LIMS, 
    saves in local directory.
    Experiment is identified by 'sample_descr' = [facility, machine, run, lane]
    """
    base_url="http://uhts-"+sample_descr[0]+".vital-it.ch"
    auth_handler = urllib2.HTTPDigestAuthHandler()
    auth_handler.add_password( realm="UHTS-LIMS-ws",
                               uri=base_url,
                               user='jrougemont',
                               passwd='cREThu6u' )
    opener = urllib2.build_opener(auth_handler)
    urllib2.install_opener(opener)
    url = "/".join([base_url,"ws","symlinkname"]+sample_descr[1:4])
    s = urllib2.urlopen(url).read()
    status = re.search(r'==(\w+)\s',s).groups()[0]
    links = re.search(r'\n(.*)\n',s).groups()[0].split("\t")
    if status == "DATA":
        link_name = links[0]
    else:
        raise ValueError("Request "+url+"\n"+links)
    url = "/".join([base_url,"ws","lanedesc"]+sample_descr[1:4])
    s = urllib2.urlopen(url).read()
    status = re.search(r'==(\w+)\s',s).groups()[0]
    lanedesc = re.search(r'\n(.*)\n',s).groups()[0].split("\t")
    if status == "DATA":
        lib_name = lanedesc[4]
    else:
        raise ValueError("Request "+url+"\n"+lanedesc)
    url = "/".join([base_url,"symlink",link_name])
    tar = tarfile.open(fileobj=urllib2.urlopen(url),mode="r|gz")
    file_loc = root+unique_filename_in(root)
    tar.extractall(path=file_loc)
    fastqname = tar.getnames()[0]
    tar.close()
    return {lib_name: file_loc+"/"+fastqname}

** TODO Write a unit test that fetches a file, md5 checks it, then deletes it :test:
Test for write_to left empty, set to a directory, and set to a filename.
** TODO Write DAFLIMS module docstring			      :documentation:
** TODO Write DAFLIMS class and method docstrings	      :documentation:

* Frontend
** TODO Unit tests for Frontend					       :test:
*** TODO Put test data for key 9pv1x7PamOj80eXnZa14 in test.py as dicts :test:
http://htsstation.vital-it.ch/rnaseq/groups.json?key=9pv1x7PamOj80eXnZa14 returned:
[
  {
    "group": {
      "name": "My first group",
      "job_id": 2,
      "control": false,
      "id": 3,
      "created_at": "2010-12-30T13:29:54Z"
    }
  },
  {
    "group": {
      "name": "Other group",
      "job_id": 2,
      "control": true,
      "id": 4,
      "created_at": "2010-12-30T13:29:54Z"
    }
  }
]
and http://htsstation.vital-it.ch/rnaseq/runs.json?key=9pv1x7PamOj80eXnZa14 returned:
[
  {
    "run": {
      "facility_name": "lgtf",
      "id": 5,
      "group_id": 3,
      "machine_name": "C3PO",
      "machine_id": 1,
      "lane_nber": 1,
      "run_nber": 36,
      "facility_location": "Lausanne",
      "created_at": "2010-12-30T13:29:54Z"
    }
  },
  {
    "run": {
      "facility_name": "lgtf",
      "id": 6,
      "group_id": 3,
      "machine_name": "C3PO",
      "machine_id": 1,
      "lane_nber": 2,
      "run_nber": 36,
      "facility_location": "Lausanne",
      "created_at": "2010-12-30T13:29:54Z"
    }
  },
  {
    "run": {
      "facility_name": "lgtf",
      "id": 7,
      "group_id": 4,
      "machine_name": "C3PO",
      "machine_id": 1,
      "lane_nber": 3,
      "run_nber": 37,
      "facility_location": "Lausanne",
      "created_at": "2010-12-30T13:29:54Z"
    }
  }
]
and http://htsstation.vital-it.ch/rnaseq/jobs/9pv1x7PamOj80eXnZa14.json for
{
  "job": {
    "remote_ip": null,
    "from_action": null,
    "bein_id": null,
    "query_string": null,
    "accept": null,
    "time": null,
    "protocol": null,
    "domain": null,
    "action": null,
    "method": null,
    "id": 2,
    "facility_id": null,
    "user_agent": null,
    "referer": null,
    "description": "Job for testing Frontend module",
    "controller": null,
    "machine_id": null,
    "path": null,
    "lane_nber": null,
    "key": "9pv1x7PamOj80eXnZa14",
    "assembly_id": 14,
    "run_nber": null,
    "input_file": null,
    "from_controller": null,
    "email": "madhadron@gmail.com",
    "created_at": "2010-12-30T13:29:54Z"
  }
}

*** TODO Write unit tests in test.py for Frontend to make sure all values are correct :test:
** TODO Write Frontend class with __init__ that checks for ConfigParser or url :frontend:
** TODO Make Frontend __init__ query Fabrice's URLs and set local fields from them :frontend:
** TODO Write module docstring for frontend.py		      :documentation: